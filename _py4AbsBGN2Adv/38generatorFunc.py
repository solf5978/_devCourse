"""
Author: Jesse Warner
Date: August 1, 2023

When a function contains the `yield` keyword, it becomes a generator function. 
Instead of returning a single value with the return keyword, generator 
functions use `yield` to produce a sequence of values. When you call a 
generator function, it doesn't execute the entire function at once. Instead, it 
returns an iterator object that can be used to retrieve the values one by one.

The `yield` keyword is used in the context of generators to create iterable 
objects that produce a sequence of values. Generators are useful for 
efficiently processing large amounts of data or for working with infinite 
sequences, where you don't know the exact number of elements in advance. They
allow you to generate values on-the-fly, reducing memory usage and improving 
performance.
"""

#***************** Create A Generator Function Using `yield` *******************

# Define a generator function that takes one parameter `limit`, which is the 
# maximum even number to generate.
def generate_even_numbers(limit):
    # Create a variable `num` initialized to zero
    num = 0

    # Loop to yield `num` and increment it by 2 each iteration until `num` is 
    # greater than `limit`
    while num <= limit:
        yield num
        num += 2

# Create a generator object by invoking the generator function and assigning it 
# to a variable.
evens = generate_even_numbers(4)

# Print `evens` to see if it contains any values generated by the generator.
print(evens) 
# Output: generator object generate_even_numbers at 0x00000228F1E882B0>
# NOTE: The memory address will change each time you run the program.

# Use a for loop to retrieve and output the values the generator function 
# generates on the fly.
for num in evens:
    print(num)
    # Output:
    # 0
    # 2
    # 4

# Define a generator function that generates an infinite number of primes.
def generate_primes():
    # There are two main variables: primes and num. 
    # The list `primes` will store the prime numbers found so far, and `num` is 
    # the number that is being checked for primality.
    primes = []
    num = 2
    # The while True loop will generate numbers indefinitely
    while True:
        # A generator expression (num % prime != 0 for prime in primes) checks 
        # if `num` is not divisible by each number `prime` in the `primes` 
        # list. The `all()` function then checks if all these conditions are 
        # true. If they are all True, num is prime and yielded from the 
        # generator. 
        if all(num % prime != 0 for prime in primes):
            yield num
            primes.append(num)
        num += 1

# Create a variable to act as a generator
prime_generator = generate_primes()

# Use list comprehension and the next() function to create a list with a 
# specified number of primes.
primes = [next(prime_generator) for i in range(10)]

# Print the primes list
print(primes) # Output: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]